<details style="margin-top: 16px">
  <summary style="cursor: pointer; color: blue;"><b>English</b></summary>



</details>

<hr>

<details style="margin-top: 16px">
  <summary style="cursor: pointer; color: blue;"><b>На русском</b></summary>

### 1. Общие понятия

#### Общее понятие

ООП (Объектно-Ориентированное Программирование) — это парадигма программирования, основанная на концепциях объектов и
классов.

#### Объект

Объект — это экземпляр класса.

```java
Car myCar=new Car();
```

#### Класс

Класс — это шаблон для создания объектов. Он описывает состояние и поведение, которое будут иметь объекты.

```java
public class Car {
    String model;
    int speed;

    void go() {
        System.out.println("This car is going");
    }
}
```

#### Поле/Атрибут

Поля класса хранят состояние объекта.

```java
public class Car {

    public int speed; // поле класса

    // other code...
}
```

#### Методы класса

Методы определяют поведение класса.

```java
public class Car {
    void go() { // поведение класса, метод класса
        System.out.println("This car is going");
    }
}
```

#### Конструктор

Конструктор — это специальный метод, вызывается при создании объекта.

##### Конструкторы по умолчанию

Java автоматически создаёт конструктор без параметров, если в классе не определены другие конструкторы.

```java
public class Car {
    public Car() {
    }
}
```

##### Конструктор с параметрами

```java
public class Car {

    public Car(String model) { //Конструктор с параметром
        this.model = model;
    }
}
```

#### `super` и `this`

`super` используется для вызова конструктора родительского класса, `this` — для доступа к полям и методам текущего
класса.

```java
public class Car extends Transport {

    private String model; // поле класса

    public Car(String model) {
        super(); // вызов конструктора родительского класса
        this.model = model; // обращение к полю текущего класса
    }
}
```

#### Getters и Setters

Методы для доступа к приватным полям.

```java
public class Car extends Transport {

    private String model;

    public Car(String model) {
        super();
        this.model = model;
    }

    public String getModel() { // getter для поля класса model 
        return this.model; // обращение к полю текущего класса
    }

    public void setModel(String model) { // setter для поля класса model 
        this.model = model; // обращение к полю текущего класса
    }
}
```

#### Особенности класса с единственным закрытым (private) конструктором

Закрытый конструктор не позволяет создать экземпляр класса извне.

```java
public class Singleton {

    private Singleton() {
    }
}
```

### 2. Инкапсуляция

#### Общее понятие

Инкапсуляция — это одна из ключевых концепций ООП, позволяющая скрыть детали реализации от внешнего мира.

#### Модификаторы доступа (private, protected, public)

Инкапсуляция реализуется с помощью модификаторов доступа.

**private**: поля и методы доступны только внутри класса.
**protected**: поля и методы доступны внутри класса и его наследников.
**public**: поля и методы доступны из любого места.

```java
public class Car {
    private String model; // доступно только внутри этого класса
    protected int speed; // доступно в этом классе и его наследниках

    public void go() {
    } // доступно из любого места
}
```

### 3. Полиморфизм

#### Общее понятие

Полиморфизм — это способность объектов разных типов обрабатываться как объекты одного типа.

#### Перегрузка конструктора

Это возможность создавать несколько конструкторов в одном классе с разным набором параметров.

```java
public class Car {
    private String model;

    public Car() {
    }

    public Car(String model) {
        this.model = model;
    }
}
```

#### Статический полиморфизм (перегрузка методов и операторов)

**Статический**: Статический полиморфизм достигается через перегрузку методов.

```java
        public void go(){}
public void go(String place){}
public void go(String formPlace,String toPlace){}
```

#### Динамический полиморфизм (переопределение методов)

**Динамический**: Динамический полиморфизм достигается через переопределение методов.

````java

public class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

public class Dog extends Animal {
    void sound() {
        System.out.println("Dog barks");
    }
}
````

**Использование**:

````java
public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Dog();
        myAnimal.sound();  // Output: Dog barks
    }
}
````

##### `equals`

- Метод equals используется для сравнения двух объектов на равенство.
- По умолчанию, этот метод наследуется от класса Object и сравнивает объекты по ссылке. То есть, два объекта считаются
  равными только в том случае, если они указывают на одно и то же место в памяти, а не по содержимому

**Переопределение** метода `equals`
Часто требуется более тонкое сравнение объектов. В этом случае метод equals переопределяется. При переопределении этого
метода, важно соблюдать контракт, который включает в себя:

- если a.equals(b) возвращает true, то и b.equals(a) должен возвращать true.
- если a.equals(b) и b.equals(c), то a.equals(c) также должен возвращать true.

```
@Override
public boolean equals(Object obj) {
        if (this == obj) {
        return true;
        }

        if (obj == null || getClass() != obj.getClass()) {
        return false;
        }

        MyObject myObject = (MyObject) obj;

        return field1 == myObject.field1 && field2.equals(myObject.field2);
        }

```

#### `toString`

Метод `toString` используется для получения строкового представления объекта. По умолчанию, этот метод возвращает строку
в формате "имя_класса@хеш_кода". В большинстве случаев, такое представление не является информативным, и метод toString
часто переопределяется для возврата более подробной информации о состоянии объекта.

````
@Override
public String toString() {
    return "MyObject{" +
        "field1=" + field1 +
        ", field2='" + field2 + '\'' +
        '}';
}

````

В этом примере, метод toString переопределен для класса MyObject так, чтобы он возвращал значения полей field1 и field2.

Оба метода equals и toString являются часто переопределяемыми и очень полезными при разработке Java-приложений для
обеспечения корректного сравнения объектов и удобного их отображения.

### 4. Наследование

#### Общее понятие

Наследование — это механизм, который позволяет одному классу наследовать поля и методы другого класса.

#### Ограничения наследования (использование `final` методов)

Если метод объявлен как **final**, он не может быть переопределен.

```
   public final void stop() { // этот метод не может быть переопределен
      // code...
   } 
```

#### Оператор `instanceof`

Оператор instanceof в Java используется для проверки, является ли объект экземпляром конкретного класса или его
подкласса, либо имплементирует ли он определенный интерфейс. Это может быть полезно, когда у вас есть ссылка на объект,
тип которого является суперклассом или интерфейсом для разных классов, и вам нужно выполнить разные действия в
зависимости от его фактического типа.

```
    if(myCar instanceof Car){
        // some code
        }
```

**Особенности и ограничения**

- null не является экземпляром никакого класса. Поэтому null instanceof ClassName всегда возвращает false.
- instanceof не может быть использован для проверки примитивных типов данных (int, float, char и т.д.).

#### Связь любого класса с классом `Object`

В Java все классы неявно наследуются от класса `Object`.

### Связь любого класса с классом `Object`

В Java, класс `Object` является корневым классом в иерархии всех классов. Это значит, что любой класс в Java является
подклассом класса `Object`, явно или неявно. Если класс не наследует от какого-либо другого класса, он автоматически
наследует от класса `Object`.

#### Примеры

##### Явное наследование

```java
class MyCustomClass extends Object {
    // Класс явно наследует от Object
}
```

##### Неявное наследование

```java
class MyCustomClass {
    // Класс неявно наследует от Object
}
```

В обоих случаях `MyCustomClass` будет иметь доступ к методам, определенным в классе `Object`.

### Основные методы класса `Object`

1. **`public String toString()`**: Возвращает строковое представление объекта. По умолчанию, это имя класса и хеш-код
   объекта.

```
    Object obj = new Object();
    System.out.println(obj.toString());  // Вывод: java.lang.Object@<hashcode>
```

2. **`public boolean equals(Object obj)`**: Сравнивает объекты на равенство. По умолчанию, метод сравнивает ссылки, а не
   содержимое.

```
    Object obj1 = new Object();
    Object obj2 = new Object();
    System.out.println(obj1.equals(obj2));  // Вывод: false
```

3. **`public final Class<?> getClass()`**: Возвращает объект `Class`, который представляет класс данного объекта.

```
    Object obj = new Object();
    System.out.println(obj.getClass());  // Вывод: class java.lang.Object
```

4. **`public int hashCode()`**: Возвращает хеш-код объекта. По умолчанию, хеш-код зависит от физического адреса в
   памяти.

Эти методы можно переопределить в своих классах для создания специфической функциональности.

Например, методы `equals()` и `hashCode()` часто переопределяются для обеспечения корректного сравнения объектов.

#### Метод `final`

Метод, объявленный как `final`, не может быть переопределен в подклассах.

#### Расширение модификаторов при наследовании, переопределении и сокрытии методов

При переопределении методов модификатор доступа может быть расширен, но не может быть сужен.

### 5. Абстракция

#### Общее понятие

Абстракция означает выделение ключевых характеристик объекта, игнорируя незначимые детали.

В контексте ООП, это означает создание класса, который содержит общую структуру и функциональность для группы
подклассов.

Пример
Представьте, что у вас есть классы Car, Boat и Airplane. Все эти транспортные средства могут перемещаться, поэтому вы
можете создать абстрактный класс Vehicle с методом move.

#### Абстрактные классы

Абстрактный класс — это класс, который не может быть инстанциирован (не может быть создан объект этого класса). Он
служит базой для других классов. В абстрактном классе можно определить абстрактные методы без реализации, а также
обычные методы с реализацией.

````java
public abstract class Vehicle {
    // Абстрактный метод
    abstract void move();

    // Обычный метод
    public void stop() {
        System.out.println("The vehicle has stopped.");
    }
}

````

#### Абстрактные методы

Абстрактные методы — это методы, которые объявлены, но не реализованы в абстрактном классе. Подклассы обязаны
предоставить реализацию для всех абстрактных методов базового класса, если они не являются абстрактными.

```java
public class Car extends Vehicle {
    @Override
    public void move() {
        System.out.println("The car is moving.");
    }
}

```

В этом примере класс Car предоставляет реализацию для абстрактного метода move базового класса Vehicle.

Теперь можно создать объект класса Car и вызвать его методы:

```java
        Vehicle myCar=new Car();
        myCar.move();  // Output: "The car is moving."
        myCar.stop();  // Output: "The vehicle has stopped."

```

**Важно отметить**, что создать объект абстрактного класса Vehicle напрямую **невозможно**:

````java
        Vehicle vehicle=new Vehicle();  // Ошибка компиляции
````

Абстрактные классы и методы — это мощный инструмент в Java для реализации абстракции и организации кода. Они позволяют
создавать общие шаблоны, которые можно переиспользовать в различных ситуациях

#### Интерфейсы

Интерфейс - это схема, определяющая контракт для классов, которые его реализуют. Интерфейс не может содержать логику
реализации, он содержит только объявления методов, которые должны быть переопределены в классе, реализующем данный
интерфейс. В этом смысле интерфейс действует как набор правил и протоколов, которым должен следовать класс.

```java
public interface Movable {
    void move();
}
```

#### Множественное наследование интерфейсов

Интерфейсы могут расширять другие интерфейсы с помощью ключевого слова extends

```java
public class Car implements Movable, Stoppable {
    // Implementation here
}
```

Еще пример:

````java

public interface Drawable {
    void draw();
}

public interface Rotatable extends Drawable {
    void rotate();
}

public class Circle implements Rotatable {
    public void draw() {
        System.out.println("Drawing a circle");
    }

    public void rotate() {
        System.out.println("Rotating the circle");
    }
}

````

В этом примере, интерфейс Rotatable расширяет интерфейс Drawable, добавляя метод rotate(). Класс Circle реализует
Rotatable, и поэтому он должен реализовать все методы из Drawable и Rotatable.

Таким образом, ключевое слово extends позволяет формировать иерархии интерфейсов,

### 6. Static, non-static методы

#### Static методы

Методы, которые принадлежат самому классу, а не его экземплярам.

```java
public static void info(){
        System.out.println("This is a car class");
        }
```

#### Non-static методы

Методы, которые принадлежат экземплярам класса.

```java
public void go(){
        System.out.println("This car is going");
        }
```

</details>
