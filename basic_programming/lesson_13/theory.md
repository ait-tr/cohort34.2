<details style="margin-top: 16px">
  <summary style="cursor: pointer; color: blue;"><b>English</b></summary>



</details>

<hr>

<details style="margin-top: 16px">
  <summary style="cursor: pointer; color: blue;"><b>На русском</b></summary>

# Сортировка пузырьком в Java

* начиная с начала массива просматриваем попарно по 2 элемента (первый со вторым, второй с третим, третий с четвертым и
  т.д.).
* Если второй элемент в паре меньше первого элемента – перемещаем его на место первого, а первый на место второго. Это
  мы делаем для всех элементов.

**тоже самое, другими словами**

1. Сравнить два элемента
2. Поменять местами или скопировать один из них
3. Перейти к следующему элементу

## Принцип работы пузырьковой сортировки.

Пузырьковая сортировка считается самой простой, но перед тем как описывать этот алгоритм давайте представим

1. Вы перемещаетесь к нулевому элементу нашего массива;
2. Сравниваете нулевой элемент с первым;
3. Если элемент на нулевой позиции оказался больше, вы меняете их местами;
4. Иначе, если элемент на нулевой позиции меньше, вы оставляете их на своих местах;
5. Производите переход на позицию правее и повторяете сравнение

### Общий принцип

Пузырьковая сортировка основана на идее "**всплытия**" наибольшего (или наименьшего) элемента массива к его **концу** (
или началу). Для этого мы проходим по массиву, сравниваем пары соседних элементов и, если они не упорядочены, меняем их
местами.

## Пузырьковая сортировка в Java: Детальный разбор

**Мы хотим отсортировать массив по возрастанию**

### Исходный массив

Начинаем с массива `[5, 2, -3, -10]`.

### Общая логика

Алгоритм пузырьковой сортировки работает, переставляя соседние элементы, если они расположены не по порядку.

---

#### Первый проход (i = 0)

**Общая задача:** Переместить наибольший элемент в конец массива.

#### Детальный разбор шагов

1. **Сравниваем 5 и 2**:

- **Почему**: 5 больше 2, и они расположены не по порядку.
- **Действие**: Меняем местами.
- **Было**: `[5, 2, -3, -10]`
- **Стало**: `[**2**, **5**, -3, -10]`

2. **Сравниваем 5 и -3**:

- **Почему**: 5 больше -3, и они расположены не по порядку.
- **Действие**: Меняем местами.
- **Было**: `[2, 5, -3, -10]`
- **Стало**: `[2, **-3**, **5**, -10]`

3. **Сравниваем 5 и -10**:

- **Почему**: 5 больше -10, и они расположены не по порядку.
- **Действие**: Меняем местами.
- **Было**: `[2, -3, 5, -10]`
- **Стало**: `[2, -3, **-10**, **5**]`

---

### Второй проход (i = 1)

**Общая задача:** Среди оставшихся элементов (первые три) переместить наибольший в конец.

#### Детальный разбор шагов

1. **Сравниваем 2 и -3**:

- **Почему**: 2 больше -3, и они расположены не по порядку.
- **Действие**: Меняем местами.
- **Было**: `[2, -3, -10, 5]`
- **Стало**: `[**-3**, **2**, -10, 5]`

2. **Сравниваем 2 и -10**:

- **Почему**: 2 больше -10, и они расположены не по порядку.
- **Действие**: Меняем местами.
- **Было**: `[-3, 2, -10, 5]`
- **Стало**: `[-3, **-10**, **2**, 5]`

---

### Третий проход (i = 2)

**Общая задача:** Среди оставшихся элементов (первые два) переместить наибольший в конец.

#### Детальный разбор шагов

1. **Сравниваем -3 и -10**:

- **Почему**: -3 больше -10, и они расположены не по порядку.
- **Действие**: Меняем местами.
- **Было**: `[-3, -10, 2, 5]`
- **Стало**: `[**-10**, **-3**, 2, 5]`

---

#### Итог

Теперь массив полностью отсортирован: `[-10, -3, 2, 5]`.

<details style="margin-top: 16px">

  <summary style="cursor: pointer; color: blue;"><b>Пример 2: [2, 7, 4, 1, 5]</b></summary>

### Первый проход (i = 0)

1. **Сравниваем 2 и 7**:

- **Действие**: Ничего не делаем (уже в правильном порядке).
- **Было**: `[2, 7, 4, 1, 5]`
- **Стало**: `[2, 7, 4, 1, 5]`

2. **Сравниваем 7 и 4**:

- **Действие**: Меняем местами.
- **Было**: `[2, 7, 4, 1, 5]`
- **Стало**: `[2, **4**, **7**, 1, 5]`

3. **Сравниваем 7 и 1**:

- **Действие**: Меняем местами.
- **Было**: `[2, 4, 7, 1, 5]`
- **Стало**: `[2, 4, **1**, **7**, 5]`

4. **Сравниваем 7 и 5**:

- **Действие**: Меняем местами.
- **Было**: `[2, 4, 1, 7, 5]`
- **Стало**: `[2, 4, 1, **5**, **7**]`

### Второй проход (i = 1)

1. **Сравниваем 2 и 4**:

- **Действие**: Ничего не делаем (уже в правильном порядке).
- **Было**: `[2, 4, 1, 5, 7]`
- **Стало**: `[2, 4, 1, 5, 7]`

2. **Сравниваем 4 и 1**:

- **Действие**: Меняем местами.
- **Было**: `[2, 4, 1, 5, 7]`
- **Стало**: `[2, **1**, **4**, 5, 7]`

3. **Сравниваем 4 и 5**:

- **Действие**: Ничего не делаем (уже в правильном порядке).
- **Было**: `[2, 1, 4, 5, 7]`
- **Стало**: `[2, 1, 4, 5, 7]`

4. **Сравниваем 5 и 7**:

- **Действие**: Ничего не делаем (уже в правильном порядке).
- **Было**: `[2, 1, 4, 5, 7]`
- **Стало**: `[2, 1, 4, 5, 7]`

### Третий проход (i = 2)

1. **Сравниваем 2 и 1**:

- **Действие**: Меняем местами.
- **Было**: `[2, 1, 4, 5, 7]`
- **Стало**: `[**1**, **2**, 4, 5, 7]`

2. **Сравниваем 2 и 4**:

- **Действие**: Ничего не делаем (уже в правильном порядке).
- **Было**: `[1, 2, 4, 5, 7]`
- **Стало**: `[1, 2, 4, 5, 7]`

3. **Сравниваем 4 и 5**:

- **Действие**: Ничего не делаем (уже в правильном порядке).
- **Было**: `[1, 2, 4, 5, 7]`
- **Стало**: `[1, 2, 4, 5, 7]`

### Четвёртый проход (i = 3)

Так как массив уже отсортирован, дополнительные проходы не требуются.

**Итоговый массив**: `[1, 2, 4, 5, 7]`

В итоге, массив станет: `[1, 2, 4, 5, 7]`


</details>

<details style="margin-top: 16px">

  <summary style="cursor: pointer; color: blue;"><b>Пример 3: [6, 5, 4, 3, 2, 1]</b></summary>

### Первый проход (i = 0)

1. **Сравниваем 6 и 5**:

- **Действие**: Меняем местами.
- **Было**: `[6, 5, 4, 3, 2, 1]`
- **Стало**: `[**5**, **6**, 4, 3, 2, 1]`

2. **Сравниваем 6 и 4**:

- **Действие**: Меняем местами.
- **Было**: `[5, 6, 4, 3, 2, 1]`
- **Стало**: `[5, **4**, **6**, 3, 2, 1]`

3. **Сравниваем 6 и 3**:

- **Действие**: Меняем местами.
- **Было**: `[5, 4, 6, 3, 2, 1]`
- **Стало**: `[5, 4, **3**, **6**, 2, 1]`

4. **Сравниваем 6 и 2**:

- **Действие**: Меняем местами.
- **Было**: `[5, 4, 3, 6, 2, 1]`
- **Стало**: `[5, 4, 3, **2**, **6**, 1]`

5. **Сравниваем 6 и 1**:

- **Действие**: Меняем местами.
- **Было**: `[5, 4, 3, 2, 6, 1]`
- **Стало**: `[5, 4, 3, 2, **1**, **6**]`

### Второй проход (i = 1)

1. **Сравниваем 5 и 4**:

- **Действие**: Меняем местами.
- **Было**: `[5, 4, 3, 2, 1, 6]`
- **Стало**: `[**4**, **5**, 3, 2, 1, 6]`

2. **Сравниваем 5 и 3**:

- **Действие**: Меняем местами.
- **Было**: `[4, 5, 3, 2, 1, 6]`
- **Стало**: `[4, **3**, **5**, 2, 1, 6]`

3. **Сравниваем 5 и 2**:

- **Действие**: Меняем местами.
- **Было**: `[4, 3, 5, 2, 1, 6]`
- **Стало**: `[4, 3, **2**, **5**, 1, 6]`

4. **Сравниваем 5 и 1**:

- **Действие**: Меняем местами.
- **Было**: `[4, 3, 2, 5, 1, 6]`
- **Стало**: `[4, 3, 2, **1**, **5**, 6]`

### Третий проход (i = 2)

1. **Сравниваем 4 и 3**:

- **Действие**: Меняем местами.
- **Было**: `[4, 3, 2, 1, 5, 6]`
- **Стало**: `[**3**, **4**, 2, 1, 5, 6]`

2. **Сравниваем 4 и 2**:

- **Действие**: Меняем местами.
- **Было**: `[3, 4, 2, 1, 5, 6]`
- **Стало**: `[3, **2**, **4**, 1, 5, 6]`

3. **Сравниваем 4 и 1**:

- **Действие**: Меняем местами.
- **Было**: `[3, 2, 4, 1, 5, 6]`
- **Стало**: `[3, 2, **1**, **4**, 5, 6]`

### Четвёртый проход (i = 3)

1. **Сравниваем 3 и 2**:

- **Действие**: Меняем местами.
- **Было**: `[3, 2, 1, 4, 5, 6]`
- **Стало**: `[**2**, **3**, 1, 4, 5, 6]`

2. **Сравниваем 3 и 1**:

- **Действие**: Меняем местами.
- **Было**: `[2, 3, 1, 4, 5, 6]`
- **Стало**: `[2, **1**, **3**, 4, 5, 6]`

### Пятый проход (i = 4)

1. **Сравниваем 2 и 1**:

- **Действие**: Меняем местами.
- **Было**: `[2, 1, 3, 4, 5, 6]`
- **Стало**: `[**1**, **2**, 3, 4, 5, 6]`

В итоге, массив станет: `[1, 2, 3, 4, 5, 6]`

</details>

### Реализация пузырьковой сортировки на языке Java

````java
class ArrayBubble {

    public static void main(String[] args) {
        // Первый цикл: проходим по всем элементам массива
        for (int i = 0; i < n - 1; i++) {
            // Второй цикл: сравниваем и меняем местами пары элементов
            for (int j = 0; j < n - 1 - i; j++) {
                // Сравниваем текущий и следующий элементы
                if (arr[j] > arr[j + 1]) {
                    // Если текущий элемент больше следующего, меняем их местами
                    int temp = arr[j];  // Временная переменная для хранения текущего элемента
                    arr[j] = arr[j + 1];  // Присваиваем текущему элементу значение следующего
                    arr[j + 1] = temp;  // Присваиваем следующему элементу сохраненное значение текущего
                }
            }
        }
    }
}
````

### Заключение

Алгоритм пузырьковой сортировки является одним из самых медленных. Если массив состоит из N элементов, то на первом
проходе будет выполнено N-1 сравнений, на втором N-2, далее N-3 и т.д.

Таким образом, при сортировке алгоритм выполняет около 0.5х(N^2) сравнений.

- Для N = 5, количество сравнений будет примерно 10
- для N = 10 количество сравнений вырастит до 45.

Таким образом, с увеличением количества элементов сложность сортировки значительно увеличивается:


# Бинарный поиск

**Бинарный поиск** — это эффективный алгоритм поиска, который работает с **отсортированными** массивами. Вместо того,
чтобы
просматривать каждый элемент массива по очереди, бинарный поиск сравнивает искомый элемент с элементом в середине
массива, а затем сужает область поиска в два раза. Это позволяет находить элементы гораздо быстрее, чем при
использовании простого перебора.

**Бинарный поиск** — это алгоритм поиска элемента в отсортированном массиве. Основная идея заключается в том, что на
каждом шаге область поиска сокращается **вдвое**.

## Шаги алгоритма

1. Инициализация: Задаем два указателя — `left и right`, которые изначально указывают на первый и последний элементы
   массива.
2. Цикл поиска: Пока `left <= right`:
    1. Середина массива: Вычисляем индекс середины массива как `mid = left + (right - left) / 2`. Это помогает избежать
       переполнения для больших массивов.
    2. Сравнение: Сравниваем элемент в середине массива (`arr[mid]`) с искомым значением (`target`).
        - Элемент найден: Если `arr[mid]` равно `target`, поиск завершен. Возвращаем индекс `mid`.
        - Элемент больше: Если `arr[mid]` больше `target`, сужаем область поиска, присваивая `right = mid - 1`.
        - Элемент меньше: Если `arr[mid]` меньше `target`, сужаем область поиска, присваивая `left = mid + 1`.
8. Завершение: Если `left > right`, элемент не найден. Возвращаем `-1` или соответствующее значение.

<details style="margin-top: 16px">
  <summary style="cursor: pointer; color: blue;"><b>Почему не просто (left + right) / 2?</b></summary>

Почему не использовать просто `(left + right) / 2` для нахождения середины. Проблема этого подхода заключается в том,
что сумма `left + right` может привести к переполнению для больших значений. Современные языки программирования, включая
Java, обычно имеют ограниченный размер для целочисленных типов данных. В случае переполнения этот подход будет давать
неверный
результат.

**Как работает left + (right - left) / 2?**

- **right - left:** Это выражение находит разницу между правым и левым индексами. Эта разница всегда будет положительной
  или нулевой, и она не
  будет [приводить к переполнению](https://ru.wikipedia.org/wiki/%D0%A6%D0%B5%D0%BB%D0%BE%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D0%B5%D1%80%D0%B5%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5),
  так как оба числа находятся внутри допустимого диапазона
  индексов массива.

- **/ 2:** Деление на 2 сокращает эту разницу вдвое, что и помогает нам найти "середину".

- **left +:** Прибавляя полученное значение к left, мы получаем индекс, который действительно находится посередине между
  left и right.

**Пример** Допустим, у нас есть массив `[1, 2, 3, 4, 5]` и `left = 0`, `right = 4`.

**По старому методу:** `(0 + 4) / 2 = 4 / 2 = 2`

**По новому методу:** `0 + (4 - 0) / 2 = 0 + 4 / 2 = 0 + 2 = 2`

В этом простом случае оба метода работают одинаково, но новый метод является более **надежным** для **избежания
переполнения целочисленных переменных**.

**Пример переполнения**

- Предположим, у нас есть массив большого размера, и значения переменных `left` и `right` близки к максимальному
  значению для типа `int`:

````
int left = 2147483640; // близко к Integer.MAX_VALUE
int right = 2147483647; // Integer.MAX_VALUE
````

- Теперь попробуем найти середину с помощью выражения `(left + right) / 2`:

````
int mid = (left + right) / 2; // Переполнение! 2147483640 + 2147483647 = 4294967287. Это число превышает максимально допустимое значение int
````

- Происходит переполнение в результате переменная mid получит некорректное значение.

**Безопасный способ**

- Вместо этого, если мы используем выражение `left + (right - left) / 2`, то переполнение не произойдет:
- Здесь (`right - left`) равно `2147483647 - 2147483640 = 7`
- Это значение безопасно делится на `2`, а затем прибавляется к `left`. Таким образом, mid будет
  равен `2147483640 + 7 / 2 = 2147483640 + 3 = 2147483643`, что является корректным значением.

</details>

### Пример

Пусть у нас есть массив arr = [1, 3, 5, 7, 9, 11], и мы ищем `target = 5`.

1. `left = 0`, `right = 5` (5 = `размер массива - 1`)
2. `mid = 0 + (5 - 0) / 2` = 2
3. `arr[mid] = 5`
4. arr[mid] равно target, поэтому возвращаем `mid = 2`.

**Примечание:** Массив должен быть отсортирован для корректной работы алгоритма.

## Пример

`[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]`

Поиск **1**

| Итерация | `left` | `right` | Участок массива                     | `mid` | `array[mid]` | Комментарий                          |
|----------|--------|---------|-------------------------------------|-------|--------------|--------------------------------------|
| 1        | 0      | 9       | [1, 3, 5, 7, 9, 11, 13, 15, 17, 19] | 4     | 9            | 9 > 1, уменьшаем `right` до 3        |
| 2        | 0      | 3       | [1, 3, 5, 7]                        | 1     | 3            | 3 > 1, уменьшаем `right` до 0        |
| 3        | 0      | 0       | [1]                                 | 0     | 1            | 1 == 1, нашли элемент. Останавливаем |

Поиск **17**

| Итерация | `left` | `right` | Участок массива                     | `mid` | `array[mid]` | Комментарий                            |
|----------|--------|---------|-------------------------------------|-------|--------------|----------------------------------------|
| 1        | 0      | 9       | [1, 3, 5, 7, 9, 11, 13, 15, 17, 19] | 4     | 9            | 9 < 17, увеличиваем `left` до 5        |
| 2        | 5      | 9       | [11, 13, 15, 17, 19]                | 7     | 15           | 15 < 17, увеличиваем `left` до 8       |
| 3        | 8      | 9       | [17, 19]                            | 8     | 17           | 17 == 17, нашли элемент. Останавливаем |

Поиск **7**

| Итерация | `left` | `right` | Участок массива                     | `mid` | `array[mid]` | Комментарий                          |
|----------|--------|---------|-------------------------------------|-------|--------------|--------------------------------------|
| 1        | 0      | 9       | [1, 3, 5, 7, 9, 11, 13, 15, 17, 19] | 4     | 9            | 9 > 7, уменьшаем `right` до 3        |
| 2        | 0      | 3       | [1, 3, 5, 7]                        | 1     | 3            | 3 < 7, увеличиваем `left` до 2       |
| 3        | 2      | 3       | [5, 7]                              | 2     | 5            | 5 < 7, увеличиваем `left` до 3       |
| 4        | 3      | 3       | [7]                                 | 3     | 7            | 7 == 7, нашли элемент. Останавливаем |

Поиск **13**

| Итерация | `left` | `right` | Участок массива                     | `mid` | `array[mid]` | Комментарий                            |
|----------|--------|---------|-------------------------------------|-------|--------------|----------------------------------------|
| 1        | 0      | 9       | [1, 3, 5, 7, 9, 11, 13, 15, 17, 19] | 4     | 9            | 9 < 13, увеличиваем `left` до 5        |
| 2        | 5      | 9       | [11, 13, 15, 17, 19]                | 7     | 15           | 15 > 13, уменьшаем `right` до 6        |
| 3        | 5      | 6       | [11, 13]                            | 5     | 11           | 11 < 13, увеличиваем `left` до 6       |
| 4        | 6      | 6       | [13]                                | 6     | 13           | 13 == 13, нашли элемент. Останавливаем |



#### Задачи для закрепления

* Найти минимальный элемент в отсортированном и повернутом массиве.
* Найти количество вхождений заданного числа в отсортированном массиве.
* Напишите бинарный поиск для нахождения квадратного корня числа с точностью до 3-го знака.
* Найти "первое" вхождение заданного числа в отсортированном массиве.
* Найти "последнее" вхождение заданного числа в отсортированном массиве.

</details>
