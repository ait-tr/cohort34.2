<details style="margin-top: 16px">
  <summary style="cursor: pointer; color: blue;"><b>English</b></summary>



</details>

<hr>

<details style="margin-top: 16px">
  <summary style="cursor: pointer; color: blue;"><b>На русском</b></summary>

- Java Collection Framework (JCF) - множество классов и интерфейсов которые реализуют наиболее часто используемые
  структуры данных. JCF состоит из двух больших подразделов: Map и Collection. Мы начинаем наше изучение с коллекций.
- Интерфейс Collection расширяет интерфейс Iterable, т. е. все коллекции итерируемые. Интерфейс Collection определяет
  некоторый основной набор методов для работы с коллекциями данных. Например добавление, удаление, поиск, получение
  колличества элементов в коллекции и т. д.
- Есть множество интерфейсов расширяющих интерфейс Collection. Мы рассмотрим интерфейсы Set и List. И начнем с
  интерфейса
  List. Интерфейс List определяет коллекции элементы которых имеют индексы, т. е. некий аналог массива, но не имеющий
  ограничения по размеру. Соответственно в интерфейсе List, помимо методов унаследованных от Iterable и Collection,
  определены методы работающие с индексами. Например вставка по индексу, удаление по индексу, получение элемента по
  индексу, поиск индекса заданного аргумента и т. п.
- Одной из имплементаций интерфейса List является класс ArrayList. Для реализации функциональности интерфейса List,
- ArrayList инкапсулирует в себе массив некоторого начального размера. Когда этот массив полностью заполняется, то его
  элементы копируются в новый массив, но уже большего размера. И теперь ждем когда заполнится новый массив. И т. д. Т.
  е. простым языком ArrayList представляет из себя "резиновый массив".

### Реализация собственной версии ArrayList

Для практического занятия мы можем взять за основу простую структуру данных, аналогичную ArrayList в Java, которую
назовем MyArrayList.
Вот базовый контур класса для реализации:

````java
public interface MyList<E> {

  // Добавляем элемент и увеличиваем размер массива, если нужно
  void add(E o);

  // Получаем элемент по индексу
  E get (int index);

  // устанавливает объект по индексу, смещая объекты
  void set(E o, int index);

  // Возвращаем размер коллекции
  int size();
  boolean contains(E o);

  // Удаляем элемент по значению
  boolean remove(E o);

  // Удаляем элемент по индексу
  E removeByIndex(int index);
}
````

- Когда элементы добавляются в ArrayList и его текущая емкость заполняется, ArrayList должен увеличить свой размер,
  чтобы вместить больше элементов. Это происходит за счет создания нового массива большего размера и копирования
  элементов из старого массива в новый.
- Процесс увеличения размера называется "расширением" (resizing) или "перераспределением" (reallocating), и хотя он
  относительно эффективен, он может быть дорогостоящим с точки зрения производительности при добавлении большого
  количества элементов, так как при каждом расширении происходит копирование всех элементов. Поэтому рекомендуется, если
  известно количество элементов или примерный верхний предел, инициализировать ArrayList с этой начальной емкостью:


````
List<String> list = new ArrayList<>(начальная_емкость);
````

Это позволит избежать лишних расширений и увеличить производительность при добавлении большого количества элементов.

#### Код с урока в github:

- https://github.com/AR1988/Ait-34_2_ArrayList
- https://github.com/AR1988/Game21_AIT


</details>
